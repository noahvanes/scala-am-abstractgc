(begin
   (define (for-each f l)
     (if (null? l) #t (if (pair? l) (begin (f (car l)) (for-each f (cdr l))) (error "Cannot for-each over a non-list"))))
   (define (my-iota n)
     (begin (define ($do-loop0 n list) (if (zero? n) list (begin ($do-loop0 (- n 1) (cons (- n 1) list))))) ($do-loop0 n '())))
   (define size 511)
   (define classmax 3)
   (define typemax 12)
   (define *iii* 0)
   (define *kount* 0)
   (define *d* 8)
   (define *piececount* (make-vector (+ classmax 1) 0))
   (define *class* (make-vector (+ typemax 1) 0))
   (define *piecemax* (make-vector (+ typemax 1) 0))
   (define *puzzle* (make-vector (+ size 1)))
   (define *p* (make-vector (+ typemax 1)))
   (define (fit i j)
     (let ((end (vector-ref *piecemax* i)))
       (begin
         (define ($do-loop1 k)
           (if (or (> k end) (and (vector-ref (vector-ref *p* i) k) (vector-ref *puzzle* (+ j k))))
             (if (> k end) #t #f)
             (begin ($do-loop1 (+ k 1)))))
         ($do-loop1 0))))
   (define (place i j)
     (let ((end (vector-ref *piecemax* i)))
       (begin
         (define ($do-loop2 k)
           (if (> k end)
             (begin)
             (begin (cond ((vector-ref (vector-ref *p* i) k) (vector-set! *puzzle* (+ j k) #t) #t)) ($do-loop2 (+ k 1)))))
         ($do-loop2 0))
       (vector-set! *piececount* (vector-ref *class* i) (- (vector-ref *piececount* (vector-ref *class* i)) 1))
       (begin
         (define ($do-loop3 k) (if (or (> k size) (not (vector-ref *puzzle* k))) (if (> k size) 0 k) (begin ($do-loop3 (+ k 1)))))
         ($do-loop3 j))))
   (define (puzzle-remove i j)
     (let ((end (vector-ref *piecemax* i)))
       (begin
         (define ($do-loop4 k)
           (if (> k end)
             (begin)
             (begin (cond ((vector-ref (vector-ref *p* i) k) (vector-set! *puzzle* (+ j k) #f) #f)) ($do-loop4 (+ k 1)))))
         ($do-loop4 0))
       (vector-set! *piececount* (vector-ref *class* i) (+ (vector-ref *piececount* (vector-ref *class* i)) 1))))
   (define (trial j)
     (let ((k 0) (return #f))
       (begin
         (define ($do-loop5 i)
           (if (or return (> i typemax))
             (begin (set! *kount* (+ *kount* 1)) return)
             (begin
               (cond
                ((not (zero? (vector-ref *piececount* (vector-ref *class* i))))
                 (cond
                  ((fit i j)
                   (set! k (place i j))
                   (cond ((or (trial k) (zero? k)) (set! *kount* (+ *kount* 1)) (set! return #t)) (else (puzzle-remove i j)))))))
               ($do-loop5 (+ i 1)))))
         ($do-loop5 0))))
   (define (definePiece iclass ii jj kk)
     (let ((index 0))
       (begin
         (define ($do-loop6 i)
           (if (> i ii)
             (begin)
             (begin
               (begin
                 (define ($do-loop7 j)
                   (if (> j jj)
                     (begin)
                     (begin
                       (begin
                         (define ($do-loop8 k)
                           (if (> k kk)
                             (begin)
                             (begin
                               (set! index (+ i (* *d* (+ j (* *d* k)))))
                               (vector-set! (vector-ref *p* *iii*) index #t)
                               ($do-loop8 (+ k 1)))))
                         ($do-loop8 0))
                       ($do-loop7 (+ j 1)))))
                 ($do-loop7 0))
               ($do-loop6 (+ i 1)))))
         ($do-loop6 0))
       (vector-set! *class* *iii* iclass)
       (vector-set! *piecemax* *iii* index)
       (cond ((not (= *iii* typemax)) (set! *iii* (+ *iii* 1))))))
   (define (start)
     (set! *kount* 0)
     (begin (define ($do-loop9 m) (if (> m size) (begin) (begin (vector-set! *puzzle* m #t) ($do-loop9 (+ m 1))))) ($do-loop9 0))
     (begin
       (define ($do-loop10 i)
         (if (> i 5)
           (begin)
           (begin
             (begin
               (define ($do-loop11 j)
                 (if (> j 5)
                   (begin)
                   (begin
                     (begin
                       (define ($do-loop12 k)
                         (if (> k 5)
                           (begin)
                           (begin (vector-set! *puzzle* (+ i (* *d* (+ j (* *d* k)))) #f) ($do-loop12 (+ k 1)))))
                       ($do-loop12 1))
                     ($do-loop11 (+ j 1)))))
               ($do-loop11 1))
             ($do-loop10 (+ i 1)))))
       ($do-loop10 1))
     (begin
       (define ($do-loop13 i)
         (if (> i typemax)
           (begin)
           (begin
             (begin
               (define ($do-loop14 m) (if (> m size) (begin) (begin (vector-set! (vector-ref *p* i) m #f) ($do-loop14 (+ m 1)))))
               ($do-loop14 0))
             ($do-loop13 (+ i 1)))))
       ($do-loop13 0))
     (set! *iii* 0)
     (definePiece 0 3 1 0)
     (definePiece 0 1 0 3)
     (definePiece 0 0 3 1)
     (definePiece 0 1 3 0)
     (definePiece 0 3 0 1)
     (definePiece 0 0 1 3)
     (definePiece 1 2 0 0)
     (definePiece 1 0 2 0)
     (definePiece 1 0 0 2)
     (definePiece 2 1 1 0)
     (definePiece 2 1 0 1)
     (definePiece 2 0 1 1)
     (definePiece 3 1 1 1)
     (vector-set! *piececount* 0 13)
     (vector-set! *piececount* 1 3)
     (vector-set! *piececount* 2 1)
     (vector-set! *piececount* 3 1)
     (let ((m (+ (* *d* (+ *d* 1)) 1)) (n 0))
       (cond ((fit 0 m) (set! n (place 0 m))) (else (begin (newline) (display "Error."))))
       (if (trial n) *kount* #f)))
   (for-each (lambda (i) (vector-set! *p* i (make-vector (+ size 1)))) (my-iota (+ typemax 1)))
   (= (start) 2005))